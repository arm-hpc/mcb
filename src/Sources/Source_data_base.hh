//----------------------------------*-C++-*----------------------------------//
// Copyright 2009 Lawrence Livermore National Security, LLC
// All rights reserved.
//---------------------------------------------------------------------------//

// This work performed under the auspices of the U.S. Department of Energy by
// Lawrence Livermore National Laboratory under Contract DE-AC52-07NA27344

//  DISCLAIMER
//  This work was prepared as an account of work sponsored by an agency of the
//  United States Government. Neither the United States Government nor the
//  Lawrence Livermore National Security, LLC, nor any of their employees,
//  makes any warranty, express or implied, including the warranties of
//  merchantability and fitness for a particular purpose, or assumes any
//  legal liability or responsibility for the accuracy, completeness, or
//  usefulness of any information, apparatus, product, or process disclosed,
//  or represents that its use would not infringe privately owned rights.

//===========================================================================//
//
// class Source_data_base - handles sources of photons for IMC
//
//===========================================================================//

#ifndef __Source_data_base_hh__
#define __Source_data_base_hh__

#include <iostream>
#include <iomanip>
#include <list>
#include <vector>
#include <cmath>

#include "photon.hh"
#include "photon_source.hh"
#include "external_source.hh"
#include "Opacity_data_base.hh"
#include "rng.hh"

namespace IMC_namespace
{

template<typename mesh_types, typename mat_types>
class Source_data_base
{
  public:
    typedef typename mesh_types::Mesh_type Mesh_type;
    typedef typename mesh_types::mesh_zone_ID_type mesh_zone_ID_type;
    typedef typename mesh_types::zcf_double zcf_double;
    typedef typename mesh_types::zcf_UINT64 zcf_UINT64;
    typedef typename mesh_types::zcf_Vector3d zcf_Vector3d;
    typedef typename mesh_types::Vector3d Vector3d;
    typedef typename mesh_types::particle_zone_ID_type particle_zone_ID_type;
    typedef typename mesh_types::ZoneIterator ZoneIterator;
    typedef typename mat_types::Material_data_base_type Material_data_base_type;
    typedef photon<particle_zone_ID_type, Vector3d> photon_type;
    typedef photon_source<mesh_types, mat_types> photon_source_type;
    typedef external_source<mesh_types, mat_types> external_source_type;
    typedef typename std::vector<photon_source<mesh_types, mat_types>*>::iterator sourceItrType;

    Source_data_base( const Mesh_type& Mesh,
                      const Material_data_base_type& Material_DB_in,
                      const Opacity_data_base<mesh_types, mat_types>& Opacity_DB_in,
                      const std::vector<photon_source_type*>& photon_source_list,
                      unsigned long long initial_seed = 1 );

    Source_data_base( const Mesh_type& Mesh,
                      const Material_data_base_type& Material_DB_in,
                      const Opacity_data_base<mesh_types, mat_types>& Opacity_DB_in,
                      const std::vector<photon_source_type*>& photon_source_list,
                      const std::vector<external_source_type*>& external_source_list,
                      unsigned long long initial_seed = 1 );

//    do stuff necessary before each timestep is run
    void setUp( double tn, double dt );

    double E_photons_cycle( double tn, double dt );

//    functions that create new photons generated by physical sources of photons
    void add_photon( sourceItrType sourceItr,
		     unsigned int element,
		     photon_type& new_photon,
		     double tn, double dt,
		     unsigned long long N_element_new,
		     double photon_Energy,
		     unsigned int photon_count,
		     unsigned int source_index,
		     std::list< photon_type >& source_photons );

    void add_photon_statistically( sourceItrType sourceItr,
				   unsigned int element,
				   photon_type& new_photon,
				   double E_desired,
				   double tn, double dt,
				   int N_killed,
				   unsigned long long N_element_new,
				   double photon_Energy,
				   unsigned int photon_count,
				   unsigned int source_index,
				   std::list< photon_type >& source_photons );

    void get_photons_from_element( sourceItrType sourceItr,
				   unsigned int element,
				   double E_desired,
				   double tn, double dt,
				   int N_killed,
				   unsigned int& N_made,
				   unsigned int source_index,
				   std::list< photon_type >& source_photons );

    void get_photons_from_source( sourceItrType sourceItr,
				  double E_desired,
				  double tn, double dt,
				  int N_killed,
				  unsigned int& N_made,
				  unsigned int source_index,
				  std::list< photon_type >& source_photons );

    void get_source_photons( unsigned long long N_cycle_photons,
                             double E_total,
                             double tn, double dt,
                             std::list<photon_type>& source_photons );

// get any resources used by external sources for this time step.
    void setUpExternalSourcePhotons();
// release any resources used by sources for this time step.
    void finalize_external_source_photons();

//    gives new photons from external sources (like other domains
//    in a domain decomposed problem) to IMC
    void get_external_source_photons( std::list<photon_type>& source_photons,
                                      double& E_entered,
                                      bool flush_buffer,
                                      unsigned long long& N_entered );

//    used in Domain Decomposed case to add a Domain_source
    void add_external_source( external_source_type* source_ptr );

    double energyBalance() const;
    void diagnosticOutput() const;

    void threadedDiagnosticOutput();

#ifdef USE_OPENMP
    void createThreadDiagnosticBuffers()
        {
            std::vector<unsigned long long>& theULLBuffer = mULLThreadedDiagnosticData();
            std::vector<double>& theDoubleBuffer = mDoubleThreadedDiagnosticData();
        }
#endif

//    called by IMC when it checks energy and photon number balance
    unsigned long long N_initial() const { return _N_initial; }
    unsigned long long N_created() const { return _N_created; }

    void RRDiagnostics( const mesh_zone_ID_type& zone,
                        unsigned long long& N_source_created,
                        unsigned long long& N_source_RR_destroyed,
                        double& E_source_created,
                        double& E_source_destroyed ) const;

    const zcf_double& get_E_emitted() const { return E_emitted; }

    double get_E_photons_total() const { return E_photons_total; }
    double get_E_input() const { return E_input; }

  private:
//   Called by ctors to set values in zcf zonal_seed, used to generate random
//   number states. After this call, each zone should have a very different
//   value, makeing sure that states of random number generators for photons
//   born in the zones are uncorreleated.
    void initialize_zonal_seed( unsigned long long initial_seed );
                                          
//    called by generate_source_photons
    void add_photons_to_source_list( double E_desired, int N_copies,
                                     unsigned int source_index,
                                     photon_type& new_photon,
                                     std::list<photon_type>& source_photons );

    const Mesh_type& Mesh;
    const Material_data_base_type& Material_DB;
    const Opacity_data_base<mesh_types, mat_types>& Opacity_DB;

//    std::vector of pointers to source objects
    std::vector<photon_source<mesh_types, mat_types>*> photon_source_list;

//    Energy input variables used by IMC
//    cummulative energy input by photon sources after RR
    double E_input;

//    cummulative photon energy before russian roullette
    double E_in_photons;
//    cummulative sum of photon energy actually created
    double E_photons_total;
    zcf_double E_emitted;
    
//    used in getting distinct seeds for each photon in each zone
    zcf_UINT64 zonal_seed;
//    next random state as a function of mesh zone
    unsigned long long next_state( const mesh_zone_ID_type& zone );

//    std::vector of external sources
    std::vector<external_source_type*> external_source_list;

//     variables used in calculating energy and photon number balance
    double E_source_RR_created, E_source_RR_destroyed;
    unsigned long long _N_initial, _N_created, N_source_RR_destroyed;

    zcf_double E_source_RR_created_zone, E_source_RR_destroyed_zone;
    zcf_UINT64 N_created_zone, N_source_RR_destroyed_zone;

//    for multiple copies of the domain running on different mpi processes
    bool domain_decomposed;
    unsigned int N_domains;
    unsigned int domainID;
    bool mesh_replicated;
    unsigned int N_replicas;
    unsigned int replicaID;
    unsigned int nProcs;
    unsigned int procID;

//     for multiple IMC instances in OpenMP environment
    bool mIsOpenMPCoarseThreaded;
    unsigned int numOmpThreads;
    unsigned int ompThreadID;

#ifdef USE_OPENMP
    std::vector<unsigned long long>& mULLThreadedDiagnosticData();
    std::vector<double>& mDoubleThreadedDiagnosticData();
#endif

//    don't want these called, so make them private
    Source_data_base();
    Source_data_base( const Source_data_base& );
    Source_data_base& operator=( const Source_data_base& );
};

}    //    namespace IMC_namespace

#endif    //    Source_data_base.hh






